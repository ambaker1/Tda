# tbl.tcl
################################################################################
# Constant-time tabular data format, using TclOO and Tcl dictionaries.

# Copyright (C) 2023 Alex Baker, ambaker1@mtu.edu
# All rights reserved. 

# See the file "LICENSE" in the top level directory for information on usage, 
# redistribution, and for a DISCLAIMER OF ALL WARRANTIES.
################################################################################

package require tda::ndlist 0.1; # For indexing

# Define table object class
namespace eval ::tda {
    namespace export tbl
}

# Definition of the table class and its methods:
oo::class create ::tda::tbl {
    # Variables used in all methods
    variable keys keymap keyname fields fieldmap fieldname data
    
    # Constructor - called by "tbl new" and "tbl create"
    constructor {args} {
        # Initialize table data
        my wipe

        # Define helper procedures within table namespace
        
        # NormalizeIndex --
        #
        # Normalize an end-integer style index
        #
        # Syntax:
        # NormalizeIndex $n $index
        # 
        # Arguments:
        # n:            Number of elements in list
        # index:        "end-integer" index notation
        
        proc NormalizeIndex {n index} {
            expr [string map [list end [expr {$n - 1}]] $index]
        }
        
        # IsUnique --
        #
        # Check if a list is unique
        #
        # Syntax:
        # IsUnique $list
        #
        # Arguments:
        # list:             List to check for uniqueness
        
        proc IsUnique {list} {
            set map ""
            foreach item $list {
                if {[dict exists $map $item]} {
                    return 0
                }
                dict set map $item ""
            }
            return 1
        }
        
        # WrongNumArgs --
        #
        # Utility function to make a typical wrong number arguments command.
        # Based on Tcl_WrongNumArgs API command
        #
        # Arguments:
        # message:          Proper syntax for command.
        
        proc WrongNumArgs {message} {
            tailcall return -code error "wrong # args: should be \"$message\""
        }
        
        # Define table with constructor input
        my define {*}$args
        return
    }
    
        
    # $tblObj wipe --
    #
    # Reset table entirely to defaults
    
    method wipe {} {
        my clear
        set fields ""; # Ordered list of fields
        set fieldmap ""; # Dictionary of fields and indices
        set keyname key; # Name of keys (first column name)
        set fieldname field; # Name of fields
        return
    }
        
    # $tblObj clear --
    #
    # Clear out all data in table (keeps keyname/fieldname, and fields/fieldmap)
    
    method clear {} {
        set data ""; # Double-nested dictionary of table data
        set keys ""; # Ordered list of keys
        set keymap ""; # dictionary of keys and indices
        return
    }
    
    # $tblObj --
    #
    # Calling the table object without any arguments will just return properties
    
    method unknown {args} {
        if {[llength $args] == 0} {
            return [my properties]
        }
        # Fall through to default processing otherwise
        next {*}$args
    }
    unexport unknown

    # $tblObj copy --
    #
    # Shorthand for copying a table object
    
    method copy {args} {
        uplevel 1 [list oo::copy [self] {*}$args]
    }
    
    # Table property definition
    ########################################################################
    
    # $tblObj define --
    # 
    # Define main table properties (everything that defines a table)
    # keys/fields must be unique
    # key-value input
    # 
    # Arguments:
    # option:       keyname, fieldname, keys, fields, or data
    # value:        corresponding values. For keys and fields, ignores dupes.
    
    method define {args} {
        # Check arity
        if {[llength $args] == 1} {
            set args [lindex $args 0]
        }
        if {[llength $args]%2 == 1} {
            WrongNumArgs "\$tblObj define name value ?name value ...?"
        }
        foreach {property value} $args {
            # Fill in metakeys
            switch $property {
                keyname { 
                    set keyname $value
                }
                fieldname {
                    set fieldname $value
                }
                keys {
                    if {![IsUnique $value]} {
                        return -code error "Keys must be unique"
                    }
                    # Redefine keys
                    set keys ""
                    set keymap ""
                    my add keys {*}$value
                    # Filter data
                    dict for {key rdict} $data {
                        if {![my exists key $key]} {
                            dict unset data $key
                        }
                    }
                }
                fields {
                    if {![IsUnique $value]} {
                        return -code error "Fields must be unique"
                    }
                    # Redefine fields
                    set fields ""
                    set fieldmap ""
                    my add fields {*}$value
                    # Filter data
                    dict for {key rdict} $data {
                        dict for {field value} $rdict {
                            if {![my exists field $field]} {
                                dict unset data $key $field
                            }
                        }
                    }
                }
                data {
                    # Overwrite data (adds any new keys/fields as well)
                    foreach key $keys {
                        dict set data $key ""
                    }
                    dict for {key rdict} $value {
                        my set $key {*}$rdict
                    }
                }
                default {
                    return -code error "Wrong option. Try \"keyname\",\
                            \"fieldname\", \"keys\", \"fields\", or \"data\""
                }
            }; # end switch
        }; # end foreach property value
        return
    }
    
    # Table property access
    ########################################################################
    
    # $tblObj properties --
    # 
    # Return a dictionary completely defining the table.
    
    method properties {} {
        return [dict create keyname $keyname fieldname $fieldname keys $keys \
                fields $fields data $data]
    }
    
    # $tblObj keyname --
    # 
    # Access keyname of table

    method keyname {} {
        return $keyname
    }
    
    # $tblObj fieldname --
    # 
    # Access fieldname of table
    
    method fieldname {} {
        return $fieldname
    }
    
    # $tblObj keys --
    # 
    # Access table keys with optional glob pattern and index pattern
    #
    # Syntax:
    # $tblObj keys <-i $i> <$pattern>
    #
    # Arguments:
    # i:            ndlist index pattern. default ":"
    # pattern:      Optional, default *
    
    method keys {args} {
        # Switch for arity
        if {[llength $args] == 0} {
            # $tblObj keys
            return $keys
        } elseif {[llength $args] == 1} {
            # $tblObj keys $pattern
            set pattern [lindex $args 0]
            return [lsearch -inline -all $keys $pattern]
        } 
        # Handle error case
        if {[llength $args] > 3 || [lindex $args 0] ne "-i"} {
            WrongNumArgs "$tblObj keys ?-i i? ?pattern?"
        }
        set i [lindex $args 1]; # index pattern
        if {[llength $args] == 2} {
            # $tblObj keys -i $i
            return [::tda::vget $keys $i]
        } elseif {[llength $args] == 3} {
            # $tblObj keys -i $i $pattern
            set pattern [lindex $args 2]
            return [lsearch -inline -all [::tda::vget $keys $i] $pattern]
        }
    }
    
    # $tblObj fields --
    # 
    # Access table fields with optional glob pattern
    #
    # Syntax:
    # $tblObj fields <-j $j> <$pattern>
    # 
    # Arguments:
    # j:            ndlist index pattern. default ":"
    # pattern:      Optional, default *
    
    method fields {args} {
        # Switch for arity
        if {[llength $args] == 0} {
            # $tblObj fields
            return $fields
        } elseif {[llength $args] == 1} {
            # $tblObj fields $pattern
            set pattern [lindex $args 0]
            return [lsearch -inline -all $fields $pattern]
        } 
        # Handle error case
        if {[llength $args] > 3 || [lindex $args 0] ne "-j"} {
            WrongNumArgs "$tblObj fields ?-j j? ?pattern?"
        }
        set j [lindex $args 1]; # index pattern
        if {[llength $args] == 2} {
            # $tblObj fields -j $j
            return [::tda::vget $fields $j]
        } elseif {[llength $args] == 3} {
            # $tblObj fields -j $j $pattern
            set pattern [lindex $args 2]
            return [lsearch -inline -all [::tda::vget $fields $j] $pattern]
        }
    }
    
    # $tblObj data --
    #
    # Access dictionary form of data (ordered by entry), with option for key
    #
    # Syntax:
    # $tblObj data <$key>
    #
    # Arguments:
    # key:          Optional, specify key
    
    method data {args} {
        if {[llength $args] == 0} {
            return $data
        } elseif {[llength $args] == 1} {
            set key [lindex $args 0]
            if {[my exists key $key]} {
                return [dict get $data $key]
            } else {
                return -code error "Unknown key \"$key\""
            }
        } else {
            WrongNumArgs "\$tblObj data ?key?"
        }
    }
    
    # Derived table properties
    ########################################################################
    
    # $tblObj values --
    #
    # Get matrix of values (alias for mget with all keys and fields)
    
    method values {} {
        my mget
    }
    
    # $tblObj shape --
    #
    # Get shape of table (number of keys and fields)
    #
    # Syntax:
    # $tblObj shape <$dim>
    #
    # Arguments:
    # dim:          0 for height, 1 for width, "" for list of height and width
    
    method shape {{dim ""}} {
        switch $dim {
            "" {
                return [list [my height] [my width]]
            }
            0 {
                return [my height]
            }
            1 {
                return [my width]
            }
            default {
                return -code error "dim must be blank, 0, or 1"
            }
        }
    }
    
    # $tblObj height --
    #
    # Number of keys in table
    
    method height {} {
        return [llength $keys]
    }
    
    # $tblObj width --
    #
    # Number of fields in table
    
    method width {} {
        return [llength $fields]
    }
    
    # $tblObj exists --
    #
    # Check if key/field or key/field pairing exists, using hashmaps
    #
    # Syntax:
    # $tblObj exists key $key
    # $tblObj exists field $field
    # $tblObj exists value $key $field
    # 
    # Arguments:
    # key:          Key to look up
    # field:        Field to look up
    
    method exists {option args} {
        switch $option {
            key { # Check if key exists
                if {[llength $args] != 1} {
                    WrongNumArgs "\$tblObj exists key name"
                }
                return [dict exists $keymap [lindex $args 0]]
            }
            field { # Check if field exists
                if {[llength $args] != 1} {
                    WrongNumArgs "\$tblObj exists field name"
                }
                return [dict exists $fieldmap [lindex $args 0]]
            }
            value { # Check if key/field pairing exists in data
                if {[llength $args] != 2} {
                    WrongNumArgs "\$tblObj exists value key field"
                }
                return [dict exists $data {*}$args]
            }
            default {
                return -code error "Incorrect option. Try key, field, or value"
            }
        }; # end switch option
    }
          
    # $tblObj find --
    # 
    # Find row/column index for a given key/field. 
    # DEPRECIATED, WILL BE REMOVED IN VERSION 1.0
    #
    # Syntax:
    # $tblObj find key $key
    # $tblObj find field $field
    #
    # Arguments:
    # key:          Key to look up
    # field:        Field to look up
    
    method find {option value} {
        switch $option {
            key { 
                return [my i $value]     
            }
            field {
                return [my j $value]
            }
            default {
                return -code error \
                        "unknown option \"$option\": want \"key\" or \"field\""
            }
        }
    }
    
    # $tblObj i --
    #
    # Get index for key
    #
    # Syntax:
    # $tblObj i $key
    #
    # Arguments:
    # key:          Key to look up
    
    method i {key} {
        if {[my exists key $key]} {
            return [dict get $keymap $key]
        } else {
            return -code error "key \"$key\" not known in table"
        }
    }
    
    # $tblObj j --
    #
    # Get index for field
    #
    # Syntax:
    # $tblObj j $field
    #
    # Arguments:
    # field:        Field to look up
    
    method j {field} {
        if {[my exists field $field]} {
            return [dict get $fieldmap $field]
        } else {
            return -code error "field \"$field\" not known in table"
        }
    }
    
    # $tblObj key --
    # 
    # Return the key associated with row index
    # Can use negative indexing per the ndlist package
    #
    # Syntax:
    # $tblObj key $i
    #
    # Arguments:
    # i:        Row index
    
    method key {i} {
        # Normalize input with ndlist package
        set i [::tda::ndlist::Index2Integer $i [llength $keys]]
        if {$i >= [llength $keys]} {
            return -code error "row index out of range"
        }
        lindex $keys $i
    }
    
    # $tblObj field --
    # 
    # Return the field associated with column index
    # Can use negative indexing per the ndlist package
    #
    # Syntax:
    # $tblObj field $j
    #
    # Arguments:
    # j:        Column index
    
    method field {j} {
        # Normalize input with ndlist package
        set j [::tda::ndlist::Index2Integer $j [llength $fields]]
        if {$j >= [llength $fields]} {
            return -code error "column index out of range"
        }
        lindex $fields $j
    }
    
    # Table entry
    ########################################################################
    
    
    
    # $tblObj set --
    #
    # Set single values in a table (single or dictionary form)
    #
    # Syntax:
    # $tblObj set $key $field $value <$field $value ...>; # odd number
    # $tblObj set -kf $key $field $value <$field $value ...>
    # $tblObj set -fk $field $key $value <$key $value ...>
    # $tblObj set -kj $key $j $value <$j $value ...>
    # $tblObj set -jk $j $key $value <$key $value ...>
    # $tblObj set -if $i $field $value <$field $value ...>
    # $tblObj set -fi $field $i $value <$i $value ...>
    # $tblObj set -ij $i $j $value <$j $value ...>
    # $tblObj set -ji $j $i $value <$i $value ...>
    # $tblObj set $i,$j $value <$i,$j $value ...>; # i-j combos
    #
    # Arguments:
    # i:            Row index
    # j:            Column index
    # key:          Row key
    # field:        Column field
    # value:        Value to set

    method set {args} {
        # Check for error
        if {[llength $args] == 1} {
            
        }
        if {[llength $args] < 3} {
            WrongNumArgs "\$tblObj set key field value ?field value ...?"
        }
        # Handle default case
        if {[llength $args] % 2 == 1} {
            set args [lassign $args key]
            # Add keys and fields
            my add keys $key
            my add fields {*}[dict keys $args]
            # Add data
            dict for {field value} $args {
                # Handle blanks
                if {$value eq ""} {
                    dict unset data $key $field
                } else {
                    dict set data $key $field $value
                }; # end if blank
            }
            return
        }
        # Handle special cases (even number of args)
        switch [lindex $args 0] {
            -kf { # Key, then field-value pairs
                my set {*}[lrange $args 1 end]; # Default case
            }
            -fk { # Field, then key-value pairs
                set field [lindex $args 1]
                foreach {key value} [lrange $args 2 end] {
                    my set $key $field $value
                }
            }
            -kj { # Key, then j-value pairs
                set key [lindex $args 1]
                foreach {j value} [lrange $args 2 end] {
                    my set $key [my field $j] $value
                }
            }
            -jk { # j, then key-value pairs
                set j [lindex $args 1]
                my set -fk [my field $j] {*}[lrange $args 2 end]
            }
            -if { # i, then field-value pairs
                set i [lindex $args 1]
                my set [my key $i] {*}[lrange $args 2 end]; # same as -kf
            }
            -fi { # field, then i-value pairs
                set field [lindex $args 1]
                foreach {i value} [lrange $args 2 end] {
                    my set [my key $i] $field $value
                }
            }
            -ij { # i, then j-value pairs
                set i [lindex $args 1]
                my set -kj [my key $i] {*}[lrange $args 2 end]
            }
            -ji { # j, then i-value pairs
                set j [lindex $args 1]
                my set -fi [my field $j] {*}[lrange $args 2 end]
            }
            default { # i,j value pairs, or {i j} value pairs
                foreach {ij value} $args {
                    if {[llength $ij] == 1} {
                        set ij [split $ij ,]
                    }
                    if {[llength $ij] != 2} {
                        return -code error "want i,j or \"i j\""
                    }
                    lassign $ij i j
                    my set [my key $i] [my field $j] $value
                }
            }
        }
        return
    }

    # $tblObj rset --
    #
    # Set entire row
    #
    # Syntax:
    # $tblObj rset <-k> $key $row
    # $tblObj rset -i $i $row
    #
    # Arguments:
    # i:            Row index
    # key:          Key associated with row
    # row:          List of values (length must match table width, or be scalar)

    method rset {args} {
        # Switch for arity
        if {[llength $args] == 2} {
            lassign $args key row
        } elseif {[llength $args] == 3} {
            switch [lindex $args 0] {
                -i { # Row index case
                    lassign [lrange $args 1 end] i row
                    set key [my key $i]
                }
                -k { # Default case
                    lassign [lrange $args 1 end] key row
                }
                default {
                    WrongNumArgs "\$tblObj rset -i i row"
                }
            }
        } else {
            WrongNumArgs "\$tblObj rset key row"
        }
        # Get input and target dimensions and check for error
        set m0 [llength $fields]
        set m1 [llength $row]
        if {$m1 == 0} {
            set type blank
        } elseif {$m1 == 1} {
            set value [lindex $row 0]
            if {$value eq ""} {
                set type blank
            } else {
                set type scalar
            }
        } elseif {$m1 == $m0} {
            set type values
        } else {
            return -code error "Inconsistent number of fields/columns"
        }
        
        # Add key
        my add keys $key
        
        # Switch for input type (blank, scalar, or values)
        switch $type {
            blank {
                dict set data $key ""
            }
            scalar {
                foreach field $fields {
                    dict set data $key $field $value
                }; # end foreach field
            }
            values {
                foreach value $row field $fields {
                    # Handle blanks
                    if {$value eq ""} {
                        dict unset data $key $field
                    } else {
                        dict set data $key $field $value
                    }; # end if blank
                }; # end foreach value/field
            }
        }; # end switch input type
            
        return
    }

    # $tblObj cset --
    #
    # Set entire column
    #
    # Syntax:
    # $tblObj cset <-f> $field $column
    # $tblObj cset -j $j $column
    # 
    # Arguments:
    # j:            Index for column
    # field:        Field associated with column
    # column:       List of values (length must match height, or be scalar)

    method cset {args} {
        # Switch for arity
        if {[llength $args] == 2} {
            lassign $args field column
        } elseif {[llength $args] == 3} {
            switch [lindex $args 0] {
                -j { # Column index case
                    lassign [lrange $args 1 end] j column
                    set field [my field $j]
                }
                -f { # Default case
                    lassign [lrange $args 1 end] field column
                }
                default {
                    WrongNumArgs "\$tblObj cset -j j column"
                }
            }
        } else {
            WrongNumArgs "\$tblObj cset field column"
        }
        # Get source and input dimensions and get input type
        set n0 [llength $keys]
        set n1 [llength $column]
        if {$n1 == 0} {
            set type blank
        } elseif {$n1 == 1} {
            set value [lindex $column 0]
            if {$value eq ""} {
                set type blank
            } else {
                set type scalar
            }
        } elseif {$n1 == $n0} {
            set type values
        } else {
            return -code error "Inconsistent number of keys/rows"
        }
        
        # Add to field list
        my add fields $field
        
        # Switch for input type (blank, scalar, or column)
        switch $type {
            blank {
                foreach key $keys {
                    dict unset data $key $field
                }; # end foreach value/field
            }
            scalar {
                foreach key $keys {
                    dict set data $key $field $value
                }; # end foreach key
            }
            values {
                foreach value $column key $keys {
                    # Handle blanks
                    if {$value eq ""} {
                        dict unset data $key $field
                    } else {
                        dict set data $key $field $value
                    }; # end if blank
                }; # end foreach value/field
            }
        }; # end switch input type
        
        return
    }

    # $tblObj mset --
    #
    # Set range of table
    #
    # Syntax:
    # $tblObj mset <-kf> <$keys $fields> $matrix
    # $tblObj mset -kj $keys $j $matrix
    # $tblObj mset -if $i $fields $matrix
    # $tblObj mset -ij $i $j $matrix
    #
    # Arguments:
    # keys:         Keys associated with rows (default all)
    # field:        Fields associated with columns (default all)
    # matrix:       Matrix of values (dimensions must match table or be scalar)

    method mset {args} {
        # Check arity
        if {[llength $args] == 1} {
            # All keys and fields
            set matrix [lindex $args 0]
            set keyset $keys
            set fieldset $fields
        } elseif {[llength $args] == 3} {
            # Specified keys and fields (validate)
            lassign $args keyset fieldset matrix
        } elseif {[llength $args] == 4} {
            switch [lindex $args 0] {
                -kf {
                    lassign [lrange $args 1 end] keyset fieldset matrix
                }
                -kj {
                    lassign [lrange $args 1 end] keyset j matrix
                    set fieldset [my fields -j $j]
                }
                -if {
                    lassign [lrange $args 1 end] i fieldset matrix
                    set keyset [my keys -i $i]
                }
                -ij {
                    lassign [lrange $args 1 end] i j matrix
                    set keyset [my keys -i $i]
                    set fieldset [my fields -j $j]
                }
                default {
                    WrongNumArgs "\$tblObj mset -ij i j matrix"
                }
            }
        } else {
            WrongNumArgs "\$tblObj mset ?keys fields? matrix"
        }
        
        # Get source and input dimensions and get input type
        set n0 [llength $keyset]
        set m0 [llength $fieldset]
        set n1 [llength $matrix]
        set m1 [llength [lindex $matrix 0]]
        if {$n1 == 0 && $m1 == 0} {
            set type blank
        } elseif {$n1 == 1 && $m1 == 1} {
            set value [lindex $matrix 0 0]
            if {$value eq ""} {
                set type blank
            } else {
                set type scalar
            }
        } elseif {$n1 == $n0 && $m1 == $m0} {
            set type values
        } else {
            return -code error "Input must be 0x0, 1x1 or ${n0}x${m0}"
        }
                
        # Add to key/field lists
        my add keys {*}$keyset
        my add fields {*}$fieldset
        
        # Switch for input type (blank, scalar, or matrix)
        switch $type {
            blank {
                foreach key $keyset {
                    foreach field $fieldset {
                        dict unset data $key $field
                    }; # end foreach value/field
                }; # end foreach row/key
            }
            scalar {
                foreach key $keyset {
                    foreach field $fieldset {
                        dict set data $key $field $value
                    }; # end foreach value/field
                }; # end foreach row/key
            }
            values {
                foreach row $matrix key $keyset {
                    foreach value $row field $fieldset {
                        # Handle blanks
                        if {$value eq ""} {
                            dict unset data $key $field
                        } else {
                            dict set data $key $field $value
                        }; # end if blank
                    }; # end foreach value/field
                }; # end foreach row/key
            }
        }; # end switch input type

        return
    }
    
    # Table access
    ########################################################################
    
    # $tblObj get --
    # 
    # Get a value from a table
    # If a key/field pairing does not exist, returns blank.
    # Return error if a key or field does not exist
    # If key and field are fieldname and keyname, respectively, returns
    # "keyname\fieldname"
    #
    # Syntax:
    # $tblObj get <-kf> $key $field
    # $tblObj get -kj $key $j
    # $tblObj get -if $i $field
    # $tblObj get -ij $i $j
    #
    # Arguments:
    # key:          key to query (fieldname to return field)
    # field:        field to query (keyname to return key)

    method get {args} {
        if {[llength $args] == 1} {
            
        }
        if {[llength $args] == 2} {
        
        } elseif {[llength $args] == 3} {
            switch [lindex $args 0] {
                -kf {
                    lassign [lrange $args 1 end] key field
                }
                -kj {
                    lassign [lrange $args 1 end] key j
                    set field [my field $j]
                }
                -if {
                    lassign [lrange $args 1 end] i field
                    set key [my key $i]
                }
                -ij {
                    lassign [lrange $args 1 end] i j
                    set key [my key $i]
                    set field [my field $j]
                }
                default {
                    WrongNumArgs "\$tblObj get -ij i j field"
                }
            }
        } else {
            WrongNumArgs "\$tblObj get key field"
        }
        # Try to get the value first (most common case)
        if {[my exists value $key $field]} {
            return [dict get $data $key $field]
        }
        # Process all other cases
        if {[my exists key $key]} {
            if {[my exists field $field]} {
                return ""; # valid key and field, but not in data
            } elseif {$field eq $keyname} {
                return $key
            } else {
                return -code error "Field \"$field\" does not exist"
            }
        } elseif {$key eq $fieldname} {
            if {[my exists field $field]} {
                return $field
            } elseif {$field eq $keyname} {
                return "$keyname\\$fieldname"; # upper left cell of table
            } else {
                return -code error "Field \"$field\" does not exist"
            }
        } else {
            return -code error "Key \"$key\" does not exist"
        }             
    }
    
	# $tblObj index --
	#
	# Get a value from a table using numbered indices
    # -1,-1 returns keyname\fieldname
    #
    # Syntax:
    # $tblObj index $i $j
    # 
	# Arguments:
	# i:          row index (-1 for fields)
	# j:          column index (-1 for keys)
    
    method index {i j} {
        my get [my key $i] [my field $j]
    }

    # $tblObj rget --
    #
    # Get a list of row values (or field headers)
    #
    # Syntax:
    # $tblObj rget $key
    #
    # Arguments:
    # key:          key to query (or fieldname)

    method rget {key} {
        lmap field $fields {
            my get $key $field
        }
    }

    # $tblObj cget --
    #
    # Get a list of column values (or key column)
    #
    # Syntax:
    # $tblObj cget $field
    #
    # Arguments:
    # field:        field to query (or keyname)

    method cget {field} {
        lmap key $keys {
            my get $key $field
        }
    }

    # $tblObj mget --
    #
    # Get a matrix of table values 
    #
    # Syntax:
    # $tblObj mget <$keys $fields>
    #
    # Arguments:
    # keys:         Keys to query (default all), fieldname for key column
    # fields:       Fields to query (default all), keyname for field header row

    method mget {args} {
        # Check arity
        if {[llength $args] == 0} {
            # All keys and fields
            set keyset $keys
            set fieldset $fields
        } elseif {[llength $args] == 2} {
            lassign $args keyset fieldset
        } else {
            WrongNumArgs "\$tblObj mget ?keys fields?"
        }
        lmap key $keyset {
            lmap field $fieldset {
                my get $key $field
            }
        }
    }
    
    # $tblObj expr --
    #
    # Perform a field expression, return list of values
    # 
    # Arguments:
    # fieldExpr:    Tcl expression, but with @ symbol for fields
    
    method expr {fieldExpr} {
        # Get mapping of fields in fieldExpr
        set exp {@\w+|@{(\\\{|\\\}|[^\\}{]|\\\\)*}}
        set fieldMap ""
        foreach {match submatch} [regexp -inline -all $exp $fieldExpr] {
            lappend fieldMap [join [string range $match 1 end]] $match
        }
        
        # Check validity of fields in field expression
        dict for {field match} $fieldMap {
            if {![dict exists $fieldmap $field] && $field ne $keyname} {
                return -code error "Field \"$field\" not in table"
            }
        }
        
        # Now, we know that the fields are valid, and we will loop through 
        # the list of keys, and use "catch"
        # Get values according to field expression
        set values ""
        foreach key $keys {
            # Perform regular expression substitution
            set subExpr $fieldExpr
            set valid 1
            foreach {field match} $fieldMap {
                if {![my exists value $key $field] && $field ne $keyname} {
                    # No data for this key/field combo. Skip.
                    set valid 0
                    break
                }
                # Subsitute value in fieldExpr
                set subExpr [regsub $match $subExpr "{[my get $key $field]}"]
            }; # end foreach fieldmap pair
            if {$valid} {
                # Only add data if all required fields exist.
                lappend values [uplevel 1 [list expr $subExpr]]
            } else {
                lappend values ""
            }; # end if valid
        }; # end foreach key
        
        # Return values created by field expression
        return $values
    }
    
    # $tblObj fedit --
    #
    # Assign or edit a column based on field expression
    # 
    # Arguments:
    # field:        Field to edit or create
    # fieldExpr:    Tcl expression, but with @ symbol for fields
    
    method fedit {field fieldExpr} {
        my cset $field [uplevel 1 [list [self] expr $fieldExpr]]
        return
    }
    
    # $tblObj query --
    #
    # Get keys that match a specific criteria from field expression
    #
    # Arguments:
    # fieldExpr:        Field expression that results in a boolean value
    
    method query {fieldExpr} {
        return [lmap bool [uplevel 1 [list [self] expr $fieldExpr]] key $keys {
            if {$bool} {
                set key
            } else {
                continue
            }
        }]
    }
    
    # $tblObj filter --
    # 
    # Reduce a table based on query results
    #
    # Arguments:
    # fieldExpr:        Field expression that results in a boolean value
    
    method filter {fieldExpr} {
        my define keys [uplevel 1 [list [self] query $fieldExpr]]
        return
    }
    
    # $tblObj search --
    #
    # Find key or keys that match a specific criteria, using lsearch.
    # If -inline is selected, filters the table instead.
    # 
    # Arguments:
    # args:         Selected lsearch options. Use -- to signal end of options.         
    # field:        Field to search in. If omitted, will search in keys.
    # value:        Value to search for.
    
    method search {args} {
        # Interpret arguments
        set options ""
        set inline false
        set remArgs ""
        set optionCheck 1
        foreach arg $args {
            if {$optionCheck} {
                # Check valid options
                if {$arg in {
                    -exact
                    -glob
                    -regexp
                    -sorted
                    -all
                    -not
                    -ascii
                    -dictionary
                    -integer
                    -nocase
                    -real
                    -decreasing
                    -increasing
                    -bisect
                }} then {
                    lappend options $arg
                    continue
                } elseif {$arg eq "-inline"} {
                    set inline true
                    continue
                } else {
                    set optionCheck 0
                    if {$arg eq {--}} {
                        continue
                    }
                }; # end check option arg
            }; # end if checking for options
            lappend remArgs $arg
        }; # end foreach arg
        
        # Process value and field arguments
        switch [llength $remArgs] {
            1 {set value [lindex $remArgs 0]}
            2 {lassign $remArgs field value}
            default {return -code error "Incorrect number of arguments"}
        }; # end switch arity of remaining

        # Handle key search case
        if {![info exists field]} {
            # Filter by keys 
            return [lsearch {*}$options -inline $keys $value]
        }

        # Filter by field values
        if {![my exists field $field]} {
            return -code error "Field \"$field\" is not in table"
        }
        
        # Check whether to include blanks or not
        set includeBlanks [expr {
            ![catch {lsearch {*}$options {{}} $value} result] && $result == 0
        }]
        
        # Get search list
        set searchList [lmap x [my cget $field] {
            expr {$includeBlanks || $x ne "" ? $x : [continue]}
        }]
        
        # Get matches and corresponding keys
        set matchList [lsearch {*}$options -index 1 -inline $searchList $value]
        if {{-all} in $options} {
            # Return key list
            set keys [lsearch -all -inline -subindices -index 0 $matchList *]
            if {$inline} {
                my define keys $keys
                return
            }
            return $keys
        } else {
            # Return key
            set key [lindex $matchList 0]
            if {$inline} {
                my define keys [list $key]
                return
            }
            return $key
        }
    }
    
    # $tblObj sort --
    # 
    # Sort a table, using lsort
    #
    # Arguments:
    # options:      Selected lsort options. Use -- to signal end of options.
    # args:         Fields to sort by
    
    method sort {args} {
        # Interpret arguments
        set options ""
        set fieldset ""
        set optionCheck 1
        foreach arg $args {
            if {$optionCheck} {
                # Check valid options
                if {$arg in {
                    -ascii
                    -dictionary
                    -integer
                    -real
                    -increasing
                    -decreasing
                    -nocase
                }} then {
                    lappend options $arg
                    continue
                } else {
                    set optionCheck 0
                    if {$arg eq "--"} {
                        continue
                    }
                }
            }
            lappend fieldset $arg
        }
    
        # Switch for sort type (keys vs fields)
        if {[llength $fieldset] == 0} {
            # Sort by keys
            set keys [lsort {*}$options $keys]
        } else {
            # Sort by field values
            foreach field $fieldset {
                # Check validity of field
                if {![my exists field $field]} {
                    return -code error "Field \"$field\" is not in table"
                }
                
                # Get column and blanks
                set cdict ""; # Column dictionary for existing values
                set blanks ""; # Keys for blank values
                foreach key $keys {
                    if {[dict exists $data $key $field]} {
                        dict set cdict $key [dict get $data $key $field]
                    } else {
                        lappend blanks $key
                    }
                }
                
                # Sort valid keys by values, and then add blanks
                set keys [concat [dict keys [lsort -stride 2 -index 1 \
                        {*}$options $cdict]] $blanks]
            }; # end foreach field
        }; # end if number of fields
        
        # Update key map
        set i 0
        foreach key $keys {
            dict set keymap $key $i
            incr i
        }
    
        return
    }
    
    # $tblObj with --
    # 
    # Loops through table (row-wise), using dict with on the table data.
    # Missing data is represented by blanks. Setting a field to blank or 
    # unsetting the variable will unset the data.
    #
    # Arguments:
    # body:         Body to evaluate

    method with {body} {
        variable temp; # Temporary variable for dict with loop
        foreach key $keys {
            # Establish keyname variable (not upvar, cannot modify)
            uplevel 1 [list set $keyname $key]
            # Create temporary row dict with blanks
            set temp [dict get $data $key]
            foreach field $fields {
                if {![dict exists $temp $field]} {
                    dict set temp $field ""
                }
            }
            # Evaluate body, using dict with
            uplevel 1 [list dict with [self namespace]::temp $body]
            # Filter out blanks
            dict set data $key [dict filter $temp value ?*]
        }
        # Return nothing
        return
    }
    
    # $tblObj merge --
    # 
    # Add table data from other tables, merging the data. 
    # keyname and fieldname must be consistent to merge.
    # 
    # Arguments:
    # args:         Tables to merge into main table
    
    method merge {args} {
        # Check compatibility
        foreach tblObj $args {
            if {$keyname ne [uplevel 1 [list $tblObj keyname]]} {
                return -code error "Cannot merge tables - keyname conflict"
            }
            if {$fieldname ne [uplevel 1 [list $tblObj fieldname]]} {
                return -code error "Cannot merge tables - fieldname conflict"
            }
        }
        # Merge input tables
        foreach tblObj $args {
            # Add keys/fields
            my add keys {*}[uplevel 1 [list $tblObj keys]]
            my add fields {*}[uplevel 1 [list $tblObj fields]]
            # Merge data
            dict for {key rdict} [uplevel 1 [list $tblObj data]] {
                dict set data $key [dict merge [dict get $data $key] $rdict]
            }
        }
        return
    }
    
    # Table manipulation
    ########################################################################
    
    # $tblObj add --
    #
    # Add keys/fields to the table, appending to end, in "dict set" fashion.
    # Duplicates may be entered with no penalty.
    # 
    # Arguments:
    # option:       "keys" or "fields"
    # args:         Keys or fields
    
    method add {option args} {
        switch $option {
            keys {
                foreach key $args {
                    if {![my exists key $key]} {
                        dict set keymap $key [llength $keys]
                        lappend keys $key
                    }
                    # Ensure that data entries exist
                    if {![dict exists $data $key]} {
                        dict set data $key ""
                    }
                }
            }
            fields {
                foreach field $args {
                    if {![my exists field $field]} {
                        dict set fieldmap $field [llength $fields]
                        lappend fields $field
                    }
                }
            }
            default {
                return -code error "Unknown option. Try \"key\" or \"field\""
            }
        }
        return
    }
    
    # $tblObj remove --
    #
    # Remove keys/fields if they exist. Handles duplicates just fine.
    #
    # Arguments:
    # option:       "keys" or "fields"
    # value:        Keys or fields
    
    method remove {option args} {
        switch $option {
            keys {
                # Get keys to remove in order of index
                set ridmap ""
                foreach key $args {
                    if {![my exists key $key]} {
                        continue
                    dict set ridmap $key [my i $key]
                    }
                }
                # Switch for number of keys to remove
                if {[dict size $ridmap] == 0} {
                    return
                } elseif {[dict size $ridmap] > 1} {
                    set ridmap [lsort -integer -stride 2 -index 1 $ridmap]
                }

                # Remove from keys and data (k-trick for performance)
                set count 0; # Count of removed values
                dict for {key i} $ridmap {
                    incr i -$count; # Adjust for removed elements
                    set keys [lreplace $keys[set keys ""] $i $i]
                    dict unset keymap $key
                    dict unset data $key
                    incr count
                }
                
                # Update keymap
                set i [lindex $ridmap 1]; # minimum removed i
                foreach key [lrange $keys $i end] {
                    dict set keymap $key $i
                    incr i
                }
            }
            fields {
                # Get fields to remove in order of index
                set cidmap ""
                foreach field $args {
                    if {![my exists field $field]} {
                        continue
                    }
                    dict set cidmap $field [my j $field]
                }
                
                # Switch for number of keys to remove
                if {[dict size $cidmap] == 0} {
                    return
                } elseif {[dict size $cidmap] > 1} {
                    set cidmap [lsort -integer -stride 2 -index 1 $cidmap]
                }   
                
                # Remove from fields and data (k-trick for performance)
                set count 0; # Count of removed values
                dict for {field j} $cidmap {
                    incr j -$count; # Adjust for removed elements
                    set fields [lreplace $fields[set fields ""] $j $j]
                    dict unset fieldmap $field
                    dict for {key rdict} $data {
                        dict unset data $key $field
                    }
                    incr count
                }
                
                # Update fieldmap
                set j [lindex $cidmap 1]; # minimum removed j
                foreach field [lrange $fields $j end] {
                    dict set fieldmap $field $j
                    incr j
                }
            }
            default {
                return -code error "Unknown option. Try \"keys\" or \"fields\""
            }
        }
        return
    }
    
    # $tblObj insert --
    # 
    # Insert keys/fields (must be unique, and no duplicates)
    #
    # Arguments:
    # option:       "keys" or "fields"
    # index:        Row or column ID (with end-integer notation)
    # args:         Keys or fields
    
    method insert {option index args} {
        switch $option {
            keys {
                # Ensure input keys are unique and new
                if {![IsUnique $args]} {
                    return -code error "Cannot have duplicate key inputs"
                }
                foreach key $args {
                    if {[my exists key $key]} {
                        return -code error "Key \"$key\" already exists"
                    }
                }
                # Convert index input to integer
                set i [::tda::ndlist::Index2Integer $index [llength $keys]]
                # Insert keys (using k-trick for performance)
                set keys [linsert $keys[set keys ""] $i {*}$args]
                # Update indices in key map
                foreach key [lrange $keys $i end] {
                    dict set keymap $key $i
                    incr i
                }
                # Ensure that entries in data exist
                foreach key $args {
                    if {![dict exists $data $key]} {
                        dict set data $key ""
                    }
                }
            }
            fields {
                # Ensure input fields are unique and new
                if {![IsUnique $args]} {
                    return -code error "Cannot have duplicate field inputs"
                }
                foreach field $args {
                    if {[my exists field $field]} {
                        return -code error "Field \"$field\" already exists"
                    }
                }
                # Convert index input to integer
                set j [::tda::ndlist::Index2Integer $index [llength $fields]]
                # Insert fields (using k-trick for performance)
                set fields [linsert $fields[set fields ""] $j {*}$args]
                # Update indices in field map
                foreach field [lrange $fields $j end] {
                    dict set fieldmap $field $j
                    incr j
                }
            }
            default {
                return -code error "Unknown option. Try \"keys\" or \"fields\""
            }
        }
        return
    }
      
    # $tblObj rename --
    #
    # Rename keys or fields in table
    #
    # Arguments:
    # option:       "keys" or "fields"
    # old:          List of old keys or fields
    # new:          List of new keys or fields

    method rename {option old new} {
        if {[llength $old] != [llength $new]} {
            return -code error "Old and new must match in length"
        }
        if {![IsUnique $old] || ![IsUnique $new]} {
            return -code error "Old and new must be unique"
        }
        switch $option {
            keys {
                # Get old rows (checks for error)
                set rows [lmap key $old {my rget $key}]
                
                # Update key list and map (requires two loops, incase of 
                # intersection between old and new lists)
                set rids ""
                foreach oldKey $old newKey $new {
                    set i [my i $oldKey]
                    lappend rids $i
                    lset keys $i $newKey
                    dict unset keymap $oldKey
                    dict unset data $oldKey
                }
                foreach newKey $new i $rids row $rows {
                    dict set keymap $newKey $i; # update in-place
                    my rset $newKey $row; # Re-add row
                }
            }
            fields {
                # Get old rows (checks for error)
                set columns [lmap field $old {my cget $field}]
                
                # Update field list and map (requires two loops, incase of 
                # intersection between old and new lists)
                set cids ""
                foreach oldField $old newField $new {
                    set j [my j $oldField]
                    lappend cids $j
                    lset fields $j $newField
                    dict unset fieldmap $oldField
                    dict for {key rdict} $data {
                        dict unset data $key $oldField
                    }
                }
                foreach newField $new j $cids column $columns {
                    dict set fieldmap $newField $j; # update in-place
                    my cset $newField $column; # Re-add column
                }
            }
            default {
                return -code error "Unknown option. Try \"keys\" or \"fields\""
            }
        }
        return
    }     

    # $tblObj mkkey --
    # 
    # Make a field the key (data loss possible)
    # If a field is empty for some keys, those keys will be lost. 
    # Additionally, if field values repeat, this will only take the last one.
    # Intended to be used with a field that is full and unique.
    # 
    # Arguments:
    # field:            Field to swap with key.
    
    method mkkey {field} {
        # Check validity of transfer
        if {[my exists field $keyname]} {
            return -code error "Keyname conflict with fields"
        }
        if {![my exists field $field]} {
            return -code error "Field \"$field\" does not exist"
        }
        
        # Restructure data and key list
        set oldData $data
        set oldKeys $keys 
        my clear
        my remove field $field
        my add fields $keyname
        foreach oldKey $oldKeys {
            # Skip entry if no data for field.
            if {![dict exists $oldData $oldKey $field]} {
                continue
            }
            set rdict [dict get $oldData $oldKey]
            set newKey [dict get $rdict $field]
            my set $newKey {*}[dict remove $rdict $field] $keyname $oldKey
        }
        # Define new keyname
        set keyname $field
        return
    }
    
    # $tblObj rmove/cmove --
    #
    # Move row to a specific row index
    # 
    # Arguments:
    # key:      Key to move
    # i:        Row index to move to.
    
    method rmove {key i} {
        # Get initial and final row indices
        set i1 [my i $key]
        set i2 [my i [my key $i]]
        # Switch for move type
        if {$i1 < $i2} {
            # Target index is beyond source
            set keys [concat [lrange $keys 0 $i1-1] [lrange $keys $i1+1 $i2] \
                    [list $key] [lrange $keys $i2+1 end]]
            set i $i1
        } elseif {$i1 > $i2} {
            # Target index is below source
            set keys [concat [lrange $keys 0 $i2-1] [list $key] \
                    [lrange $keys $i2 $i1-1] [lrange $keys $i1+1 end]]
            set i $i2
        } else {
            # Trivial case
            return
        }
        # Update keymap
        foreach key [lrange $keys $i end] {
            dict set keymap $key $i
            incr i
        }
        return
    }
    
    # $tblObj rmove --
    #
    # Move column to a specific column index
    # 
    # Arguments:
    # field:    Field to move
    # j:        Column index to move to.
    
    method cmove {field j} {
        # Get source index, checking validity of field
        set j1 [my j $field]
        set j2 [my j [my field $j]]
        # Switch for move type
        if {$j1 < $j2} {
            # Target index is beyond source
            set fields [concat [lrange $fields 0 $j1-1] \
                    [lrange $fields $j1+1 $j2] [list $field] \
                    [lrange $fields $j2+1 end]]
            set j $i
        } elseif {$j1 > $j2} {
            # Target index is below source
            set fields [concat [lrange $fields 0 $j2-1] [list $field] \
                    [lrange $fields $j2 $j1-1] [lrange $fields $j1+1 end]]
            set j $j2
        } else {
            # Trivial case
            return
        }
        # Update fieldmap
        foreach field [lrange $fields $j end] {
            dict set fieldmap $field $j
            incr j
        }
        return
    }
    
    # $tblObj rswap/cswap --
    #
    # Swap rows/columns
    #
    # Arguments:
    # key1/field1:       Key or field 1
    # key2/field2:       Key or field 2
    
    method rswap {key1 key2} {
        # Check existence of keys
        foreach key [list $key1 $key2] {
            if {![dict exists $keymap $key]} {
                return -code error "Key \"$key\" is not in table"
            }
        }
        # Get row IDs
        set rid1 [dict get $keymap $key1]
        set rid2 [dict get $keymap $key2]
        # Update key list and map
        lset keys $rid2 $key1
        lset keys $rid1 $key2
        dict set keymap $key1 $rid2
        dict set keymap $key2 $rid1
        return
    }
    
    method cswap {field1 field2} {
        # Check existence of fields
        foreach field [list $field1 $field2] {
            if {![dict exists $fieldmap $field]} {
                return -code error "Field \"$field\" is not in table"
            }
        }
        # Get column IDs
        set cid1 [dict get $fieldmap $field1]
        set cid2 [dict get $fieldmap $field2]
        # Update field list and map
        lset fields $cid2 $field1
        lset fields $cid1 $field2
        dict set fieldmap $field1 $cid2
        dict set fieldmap $field2 $cid1
        return
    }
    
    # $tblObj transpose --
    # 
    # Transpose a table
    
    method transpose {} {
        # Initialize transpose data
        foreach field $fields {
            dict set transpose $field ""
        }
        # Swap keys/fields
        lassign [list $keyname $fieldname] fieldname keyname
        lassign [list $keys $fields] fields keys
        lassign [list $keymap $fieldmap] fieldmap keymap
        # Transpose data
        dict for {key rdict} $data {
            dict for {field value} $rdict {
                dict set transpose $field $key $value
            }
        }
        set data $transpose
        return
    }    
    
    # $tblObj clean --
    #
    # Clear keys and fields that don't exist in data
    
    method clean {} {
        # Remove blank keys
        set blankKeys ""
        foreach key $keys {
            if {[dict size [dict get $data $key]] == 0} {
                lappend blankKeys $key
            }
        }
        my remove keys {*}$blankKeys
        # Remove blank fields
        set blankFields ""
        foreach field $fields {
            set isBlank 1
            dict for {key rdict} $data {
                if {[dict exists $rdict $field]} {
                    set isBlank 0
                    break
                }
            }
            if {$isBlank} {
                lappend blankFields $field
            }
        }
        my remove fields {*}$blankFields
        return
    }
}

# Finally, provide the package
package provide tda::tbl @VERSION_TBL@
